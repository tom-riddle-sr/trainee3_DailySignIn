// Code generated by mockery v2.43.2. DO NOT EDIT.

package mocks

import (
	mysql_trainee3 "trainee3/model/entity/mysql/mysql_trainee3"

	mock "github.com/stretchr/testify/mock"
	gorm "gorm.io/gorm"
)

// IMysql is an autogenerated mock type for the IMysql type
type IMysql struct {
	mock.Mock
}

type IMysql_Expecter struct {
	mock *mock.Mock
}

func (_m *IMysql) EXPECT() *IMysql_Expecter {
	return &IMysql_Expecter{mock: &_m.Mock}
}

// Query provides a mock function with given fields: db, model, condition, values
func (_m *IMysql) Query(db *gorm.DB, model interface{}, condition string, values ...interface{}) error {
	var _ca []interface{}
	_ca = append(_ca, db, model, condition)
	_ca = append(_ca, values...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Query")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(*gorm.DB, interface{}, string, ...interface{}) error); ok {
		r0 = rf(db, model, condition, values...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// IMysql_Query_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Query'
type IMysql_Query_Call struct {
	*mock.Call
}

// Query is a helper method to define mock.On call
//   - db *gorm.DB
//   - model interface{}
//   - condition string
//   - values ...interface{}
func (_e *IMysql_Expecter) Query(db interface{}, model interface{}, condition interface{}, values ...interface{}) *IMysql_Query_Call {
	return &IMysql_Query_Call{Call: _e.mock.On("Query",
		append([]interface{}{db, model, condition}, values...)...)}
}

func (_c *IMysql_Query_Call) Run(run func(db *gorm.DB, model interface{}, condition string, values ...interface{})) *IMysql_Query_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(*gorm.DB), args[1].(interface{}), args[2].(string), variadicArgs...)
	})
	return _c
}

func (_c *IMysql_Query_Call) Return(_a0 error) *IMysql_Query_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *IMysql_Query_Call) RunAndReturn(run func(*gorm.DB, interface{}, string, ...interface{}) error) *IMysql_Query_Call {
	_c.Call.Return(run)
	return _c
}

// QueryAll provides a mock function with given fields: db, model, rewardList, condition, values
func (_m *IMysql) QueryAll(db *gorm.DB, model interface{}, rewardList *[]mysql_trainee3.DSReward, condition string, values ...interface{}) error {
	var _ca []interface{}
	_ca = append(_ca, db, model, rewardList, condition)
	_ca = append(_ca, values...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for QueryAll")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(*gorm.DB, interface{}, *[]mysql_trainee3.DSReward, string, ...interface{}) error); ok {
		r0 = rf(db, model, rewardList, condition, values...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// IMysql_QueryAll_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'QueryAll'
type IMysql_QueryAll_Call struct {
	*mock.Call
}

// QueryAll is a helper method to define mock.On call
//   - db *gorm.DB
//   - model interface{}
//   - rewardList *[]mysql_trainee3.DSReward
//   - condition string
//   - values ...interface{}
func (_e *IMysql_Expecter) QueryAll(db interface{}, model interface{}, rewardList interface{}, condition interface{}, values ...interface{}) *IMysql_QueryAll_Call {
	return &IMysql_QueryAll_Call{Call: _e.mock.On("QueryAll",
		append([]interface{}{db, model, rewardList, condition}, values...)...)}
}

func (_c *IMysql_QueryAll_Call) Run(run func(db *gorm.DB, model interface{}, rewardList *[]mysql_trainee3.DSReward, condition string, values ...interface{})) *IMysql_QueryAll_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-4)
		for i, a := range args[4:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(*gorm.DB), args[1].(interface{}), args[2].(*[]mysql_trainee3.DSReward), args[3].(string), variadicArgs...)
	})
	return _c
}

func (_c *IMysql_QueryAll_Call) Return(_a0 error) *IMysql_QueryAll_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *IMysql_QueryAll_Call) RunAndReturn(run func(*gorm.DB, interface{}, *[]mysql_trainee3.DSReward, string, ...interface{}) error) *IMysql_QueryAll_Call {
	_c.Call.Return(run)
	return _c
}

// Save provides a mock function with given fields: db, model
func (_m *IMysql) Save(db *gorm.DB, model interface{}) error {
	ret := _m.Called(db, model)

	if len(ret) == 0 {
		panic("no return value specified for Save")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(*gorm.DB, interface{}) error); ok {
		r0 = rf(db, model)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// IMysql_Save_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Save'
type IMysql_Save_Call struct {
	*mock.Call
}

// Save is a helper method to define mock.On call
//   - db *gorm.DB
//   - model interface{}
func (_e *IMysql_Expecter) Save(db interface{}, model interface{}) *IMysql_Save_Call {
	return &IMysql_Save_Call{Call: _e.mock.On("Save", db, model)}
}

func (_c *IMysql_Save_Call) Run(run func(db *gorm.DB, model interface{})) *IMysql_Save_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*gorm.DB), args[1].(interface{}))
	})
	return _c
}

func (_c *IMysql_Save_Call) Return(_a0 error) *IMysql_Save_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *IMysql_Save_Call) RunAndReturn(run func(*gorm.DB, interface{}) error) *IMysql_Save_Call {
	_c.Call.Return(run)
	return _c
}

// Update provides a mock function with given fields: db, condition, value, model, model2
func (_m *IMysql) Update(db *gorm.DB, condition string, value interface{}, model interface{}, model2 map[string]interface{}) error {
	ret := _m.Called(db, condition, value, model, model2)

	if len(ret) == 0 {
		panic("no return value specified for Update")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(*gorm.DB, string, interface{}, interface{}, map[string]interface{}) error); ok {
		r0 = rf(db, condition, value, model, model2)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// IMysql_Update_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Update'
type IMysql_Update_Call struct {
	*mock.Call
}

// Update is a helper method to define mock.On call
//   - db *gorm.DB
//   - condition string
//   - value interface{}
//   - model interface{}
//   - model2 map[string]interface{}
func (_e *IMysql_Expecter) Update(db interface{}, condition interface{}, value interface{}, model interface{}, model2 interface{}) *IMysql_Update_Call {
	return &IMysql_Update_Call{Call: _e.mock.On("Update", db, condition, value, model, model2)}
}

func (_c *IMysql_Update_Call) Run(run func(db *gorm.DB, condition string, value interface{}, model interface{}, model2 map[string]interface{})) *IMysql_Update_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*gorm.DB), args[1].(string), args[2].(interface{}), args[3].(interface{}), args[4].(map[string]interface{}))
	})
	return _c
}

func (_c *IMysql_Update_Call) Return(_a0 error) *IMysql_Update_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *IMysql_Update_Call) RunAndReturn(run func(*gorm.DB, string, interface{}, interface{}, map[string]interface{}) error) *IMysql_Update_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateColumns provides a mock function with given fields: db, model, cols
func (_m *IMysql) UpdateColumns(db *gorm.DB, model interface{}, cols map[string]interface{}) error {
	ret := _m.Called(db, model, cols)

	if len(ret) == 0 {
		panic("no return value specified for UpdateColumns")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(*gorm.DB, interface{}, map[string]interface{}) error); ok {
		r0 = rf(db, model, cols)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// IMysql_UpdateColumns_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateColumns'
type IMysql_UpdateColumns_Call struct {
	*mock.Call
}

// UpdateColumns is a helper method to define mock.On call
//   - db *gorm.DB
//   - model interface{}
//   - cols map[string]interface{}
func (_e *IMysql_Expecter) UpdateColumns(db interface{}, model interface{}, cols interface{}) *IMysql_UpdateColumns_Call {
	return &IMysql_UpdateColumns_Call{Call: _e.mock.On("UpdateColumns", db, model, cols)}
}

func (_c *IMysql_UpdateColumns_Call) Run(run func(db *gorm.DB, model interface{}, cols map[string]interface{})) *IMysql_UpdateColumns_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*gorm.DB), args[1].(interface{}), args[2].(map[string]interface{}))
	})
	return _c
}

func (_c *IMysql_UpdateColumns_Call) Return(_a0 error) *IMysql_UpdateColumns_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *IMysql_UpdateColumns_Call) RunAndReturn(run func(*gorm.DB, interface{}, map[string]interface{}) error) *IMysql_UpdateColumns_Call {
	_c.Call.Return(run)
	return _c
}

// NewIMysql creates a new instance of IMysql. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewIMysql(t interface {
	mock.TestingT
	Cleanup(func())
}) *IMysql {
	mock := &IMysql{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
